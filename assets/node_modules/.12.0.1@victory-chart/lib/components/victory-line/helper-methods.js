Object.defineProperty(exports,"__esModule",{value:true});var _last2=require("lodash/last");var _last3=_interopRequireDefault(_last2);var _defaults2=require("lodash/defaults");var _defaults3=_interopRequireDefault(_defaults2);var _sortBy2=require("lodash/sortBy");var _sortBy3=_interopRequireDefault(_sortBy2);
var _victoryCore=require("victory-core");
var _data=require("../../helpers/data");var _data2=_interopRequireDefault(_data);
var _domain=require("../../helpers/domain");var _domain2=_interopRequireDefault(_domain);
var _scale=require("../../helpers/scale");var _scale2=_interopRequireDefault(_scale);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=

{

getBaseProps:function getBaseProps(props,fallbackProps){
props=_victoryCore.Helpers.modifyProps(props,fallbackProps,"line");
var defaultStyles=props.theme&&props.theme.line&&props.theme.line.style?
props.theme.line.style:{};
var calculatedValues=this.getCalculatedValues(props);var
scale=calculatedValues.scale;var dataset=calculatedValues.dataset;
var style=_victoryCore.Helpers.getStyles(props.style,defaultStyles,"auto","100%");var _props=
props;var interpolation=_props.interpolation;var label=_props.label;var width=_props.width;var height=_props.height;
var dataStyle=_victoryCore.Helpers.evaluateStyle(style.data,dataset);
var dataProps={
scale:scale,
interpolation:_victoryCore.Helpers.evaluateProp(interpolation,dataset),
style:dataStyle};

var parentProps={style:style.parent,scale:scale,data:dataset,width:width,height:height};
var baseProps={
parent:parentProps,
all:{
data:dataProps}};



var text=_victoryCore.Helpers.evaluateProp(label,dataset);
if(text!==undefined||props.events||props.sharedEvents){
baseProps.all.labels=this.getLabelProps(dataProps,text,calculatedValues,style);
}

return baseProps;
},

getLabelProps:function getLabelProps(dataProps,text,calculatedValues,style){// eslint-disable-line max-params
var dataSegments=calculatedValues.dataSegments;var dataset=calculatedValues.dataset;var scale=calculatedValues.scale;var
dataStyle=dataProps.style;
var lastData=(0,_last3.default)((0,_last3.default)(dataSegments));
var baseLabelStyle=_victoryCore.Helpers.evaluateStyle(style.labels,dataset)||{};
var labelStyle=this.getLabelStyle(baseLabelStyle,dataStyle);

return{
x:lastData?scale.x(lastData.x1||lastData.x)+(labelStyle.padding||0):0,
y:lastData?scale.y(lastData.y1||lastData.y):0,
style:labelStyle,
textAnchor:labelStyle.textAnchor||"start",
verticalAnchor:labelStyle.verticalAnchor||"middle",
angle:labelStyle.angle,
scale:scale,
text:text};

},

getScale:function getScale(props,fallbackProps){
if(fallbackProps){
props=_victoryCore.Helpers.modifyProps(props,fallbackProps);
}
var range={
x:_victoryCore.Helpers.getRange(props,"x"),
y:_victoryCore.Helpers.getRange(props,"y")};

var domain={
x:_domain2.default.getDomain(props,"x"),
y:_domain2.default.getDomain(props,"y")};

var scale={
x:_scale2.default.getBaseScale(props,"x").domain(domain.x).range(range.x),
y:_scale2.default.getBaseScale(props,"y").domain(domain.y).range(range.y)};


return scale;
},

getCalculatedValues:function getCalculatedValues(props){
var dataset=_data2.default.getData(props);

if(_data2.default.getData(props).length<2){
_victoryCore.Log.warn("VictoryLine needs at least two data points to render properly.");
dataset=[];
}

var dataSegments=this.getDataSegments(dataset);
var scale=this.getScale(props);

return{dataset:dataset,dataSegments:dataSegments,scale:scale};
},

getLabelStyle:function getLabelStyle(labelStyle,dataStyle){
// match labels styles to data style by default (fill, opacity, others?)
var opacity=dataStyle.opacity;
// match label color to data color if it is not given.
// use fill instead of stroke for text
var fill=dataStyle.stroke;
var padding=labelStyle.padding||0;
return(0,_defaults3.default)({},labelStyle,{opacity:opacity,fill:fill,padding:padding});
},

getDataSegments:function getDataSegments(dataset){var sortKey=arguments.length<=1||arguments[1]===undefined?"x":arguments[1];
var orderedData=(0,_sortBy3.default)(dataset,sortKey);
var segments=[];
var segmentStartIndex=0;
var segmentIndex=0;
for(var index=0,len=orderedData.length;index<len;index++){
var datum=orderedData[index];
if(datum.y===null||typeof datum.y==="undefined"){
segments[segmentIndex]=orderedData.slice(segmentStartIndex,index);
segmentIndex++;
segmentStartIndex=index+1;
}
}
segments[segmentIndex]=orderedData.slice(segmentStartIndex,orderedData.length);
return segments.filter(function(segment){
return Array.isArray(segment)&&segment.length>0;
});
}};